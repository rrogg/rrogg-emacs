#+title: rrogg-emacs - My GNU Emacs Configuration
#+startup: content indent

* The Early Initialisation of Emacs (=early-init.el=)

** Maximize Frame

The Emacs frame is maximized at all times to make use of every pixel
on the screen.

#+begin_src emacs-lisp :tangle "early-init.el"
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Hide Welcome Screen and Empty =*scratch*=

Emacs shows a splash screen at startup from which one can easily get
to the tutorial. While helpful in the beginning, this screen gets
abdicable with time. Therefore it's disabled.
Emacs also automatically loads a buffer called =*scratch*=, which
serves as a place to try out emacs lisp code or to type out some
ideas. This is very helpful as one doesn't have to think about
creating a new file for every unrelated thought. The welcome message
isn't needed, so it's disabled.

#+begin_src emacs-lisp :tangle "early-init.el"
(setq inhibit-startup-screen t
      initial-scratch-message nil)
#+end_src

** Disable Ringing the Bell

No audible alerts on errors.

#+begin_src emacs-lisp :tangle "early-init.el"
(setq ring-bell-function 'ignore)
#+end_src

** Disable GUI Bar Components

Display no GUI components other than the =modline=.

#+begin_src emacs-lisp :tangle "early-init.el"
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

** Initialise the Package Cache

Initialise installed packages and make them available when Emacs
starts. This must be set in the =early-init.el= in order to make the
packages available before reading the =init.el=. 

#+begin_src emacs-lisp :tangle "early-init.el"
(setq package-enable-at-startup t)
#+end_src

** Avoid the Initial Flash of Light

The default Emacs theme that is loaded initially is white.
This causes a "flash of light" if a dark theme is selected by the
user, as the basic colour values at startup are still loaded first.
The funtions below will hardcode the background colour to black and
then load the theme the user wants.
This function is from the config of [[https://protesilaos.com][Protesilaos Stavrou]].

#+begin_src emacs-lisp :tangle "early-init.el"
(defun prot-emacs-re-enable-frame-theme (_frame)
  "Re-enable active theme, if any, upon FRAME creation.
Add this to `after-make-frame-functions' so that new frames do
not retain the generic background set by the function
`prot-emacs-avoid-initial-flash-of-light'."
  (when-let* ((theme (car custom-enabled-themes)))
    (enable-theme theme)))

(defun prot-emacs-avoid-initial-flash-of-light ()
  "Avoid flash of light when starting Emacs, if needed.
New frames are instructed to call `prot-emacs-re-enable-frame-theme'."
  (setq mode-line-format nil)
  (set-face-attribute 'default nil :background "#000000" :foreground "#ffffff")
  (set-face-attribute 'mode-line nil :background "#000000" :foreground "#ffffff" :box 'unspecified)
  (add-hook 'after-make-frame-functions #'prot-emacs-re-enable-frame-theme))

(prot-emacs-avoid-initial-flash-of-light)
#+end_src

* The Main Initialisation of Emacs (=init.el=)

** Backups and Lockfiles

Emacs creates backups of files automatically by default. I like to
decide what gets backuped where on my own.
Files don't need to be locked to prevent external programs from
editing these, because I should be aware of it and actually want this
to happen.

#+begin_src emacs-lisp :tangle "init.el"
(setq make-backup-files nil)
(setq create-lockfiles nil)
#+end_src

** Text Manipulation and Language

*** The =TAB= Key: Indentation and Completion

The =TAB= key tries to indent the current line or paragraph. If the
text can't be indented, it will try to do a completion at
point. ~tab-always-indent~ is set to accomplish this.
Exceptions for completing are controlled by ~tab-first-completion~.
A =TAB= shall always be a number of spaces, defined by ~tab-width~,
and never an actual tab.

#+begin_src emacs-lisp :tangle "init.el"
(use-package emacs
  :ensure nil
  :demand t
  :config
  (setq tab-always-indent 'complete)
  (setq tab-first-completion 'word-or-paren-or-punct)
  (setq-default tab-width 4
                indent-tabs-mode nil))
#+end_src

*** Wrap Lines at a Reasonable Width

Long lines of text are wrapped at a width of 70 characters to improve
readability. In order to leave long code lines untouched, automatic
line wrap is only active in =text-mode= and modes which inherit from
it, like =org-mode=.
Emacs default is that a sentence ends with a double space. One space
after the end of a sentence, which is marked by a period, feels more
natural for me.

#+begin_src emacs-lisp :tangle "init.el"
(use-package text-mode
  :ensure nil
  :mode "\\`\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)\\'"
  :hook
  (text-mode . turn-on-auto-fill)
  :config
  (setq-default fill-column 70 )
  (setq sentence-end-double-space nil)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t))
#+end_src

** Providing and Managing Packages
*** =package.el=

Most extensions to Emacs can be loaded from archives, which are
accessible via Emacs' very own package manager =package.el=. To use
this feature, =package.el= needs to know, which archives it should
use.
Out of the box, Emacs includes the =GNU ELPA= archive. It contains
packages conform with the terms of the Free Software Foundation.

#+begin_src emacs-lisp :tangle "init.el"
(setq package-archives
      '(("gnu-elpa" . "https://elpa.gnu.org/packages/")
        ("gnu-elpa-devel" . "https://elpa.gnu.org/devel/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa" . "https://melpa.org/packages/")))

;; Highest number gets priority (what is not mentioned has priority 0)
(setq package-archive-priorities
      '(("gnu-elpa" . 3)
        ("melpa" . 2)
        ("nongnu" . 1)))
#+end_src

The command =M-x list-packages= brings up the package menu buffer,
which lists all packages available from the archives defined above.
The command retrieves the list of packages from the archive servers,
if it has a connection to the internet. Else it uses the most recently
retrieved list.

Here are some of the frequently used commands in the package menu
buffer:

| Key     | Command                      | Description                                                                                                                                                |
|---------+------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------|
| h       | (package-menu-quick-help)    | Summary of commands in the package menu buffer                                                                                                             |
| r       | (package-menu-refresh)       | Refresh package list                                                                                                                                       |
| i       | (package-menu-mark-install)  | Mark the package on the current line for installation (adds an ‘I’ character to the start of the line)                                                     |
| d       | (package-menu-mark-delete)   | Mark the package on the current line for deletion (adds a ‘D’ character to the start of the line                                                           |
| u <RET> |                              | Remove any installation or deletion mark previously added to the current line                                                                              |
| U       | (package-menu-mark-upgrades) | Mark all package with a newer available version for upgrading.  This places an ‘I’ on the new available versions, and a ‘D’ on the old installed versions. |
| x       | (package-menu-execute)       | Download and install all packages marked with ‘I’, and their dependencies; also, delete all packages marked with ‘D’                                       |

The command =(package-install PKG)= can be used to install package
"PKG" manually from a code block.

*** =use-package=

Most Emacs configurations out there tend to be quite extensive. I
expect nothing else for mine. Over time, it will grow and become
cluttered. Loading time will most likely go up linked to the size of
packages used.
Having more control over when things get loaded or when certain code
is executed is very welcome.
The macro =use-package= provides this control. It isolates packages
configuration in an Emacs config so that code belonging to a certain
package only is executed when the package is loaded. When a package is
loaded it is also configurable. This has the potential to squeeze some
performance out of this config and to make it clean, tidy and
organized.

=use-package= provides several keywords to load and configure a
package. See a basic example below.

#+begin_example emacs-lisp
(use-package foo
  :ensure t
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
#+end_example

The macro starts with =use-package foo=, which will load the package
=foo=, but only, if it's already available on the system (else, a
warning gets logged).

=:ensure t= makes sure, that the package is installed and will
download it from the package archives, if it's not present on the
system. This is how packages are fetched and installed in Cortex.

The =:init= keyword executes code before a package is loaded. It
accepts one or more forms, up to the next keyword.

Similarly, =:config= can be used to execute code after a package is
loaded.
** git

*** How to Write a Good Commit Message

A good commit message follows [[https://chris.beams.io/posts/git-commit/][7 rules]]:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs. how

For example:

#+begin_example
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
#+end_example

*** magit

=magit= is a superb interface to =git=.

All stylistic rules can be taken care of by =magit=. It will color
characters on the summary line exceeding length of 50 red and does the
same for the second line, which should be blank. The body of the
message is wrapped at length 70.

#+begin_src emacs-lisp :tangle "init.el"
(use-package magit
  :ensure t
  :bind ("C-c g" . magit-status)
  :hook (git-commit-setup . rrogg-git-commit-setup)
  :init
  (setq magit-define-global-key-bindings nil)
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq git-commit-fill-column 70)
  (defun rrogg-git-commit-setup()
    (insert "#1. Capitalize the subject line
#2. Do not end the subject line with a period
#3. Use the present tense imperative mood in the subject line and body
#4. Use the body to explain what and why vs. how
#-----------------------------------------------
#If applied, this commit will …
")))
#+end_src

** Save Commands Across Sessions

Emacs doesn't have a persistent command history by default. The
build-in history gets resetted with every new Emacs session. The
package =savehist= implements a session independent history.

#+begin_src emacs-lisp :tangle "init.el"
(use-package savehist
  :ensure nil
  :hook (after-init . savehist-mode)
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 100)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-to-list 'savehist-additional-variables 'kill-ring))
#+end_src

** Themes

The look of Emacs is defined in a theme. Custom themes usually alter
e.g. the colors used to highlight headings or code. Readability and
accessibility has highest priority. This may be to the expense of
having a "stylish" looking Emacs, but that's OK.

I found out about the =Modus= themes created by [[https://protesilaos.com][Protesilaos Stavrou]]
while watching one of his videos about Emacs. Those themes are conform
with the highest accessibility standard for color contrast between
background and foreground values (WCAG AAA).

The themes are shipped with Emacs since version =28.1=. The latest
version is also available from ELPA. The ELPA version is the one I
use.

=Modus Operandi= is the light variant.
=Modus Vivendi= is the dark variant.

The themes come with a lot of options for customization. If those are
used, they need to be set prior to the loading of the theme.

#+begin_src emacs-lisp :tangle "init.el"
(use-package modus-themes
  :ensure t
  :demand t
  :bind (("<f5>" . modus-themes-toggle)
         ("C-<f5>" . modus-themes-select))
  :config
  (setq modus-themes-to-toggle '(modus-operandi modus-vivendi))
  (setq modus-themes-mixed-fonts t)
  (modus-themes-load-theme (cadr modus-themes-to-toggle)))
#+end_src

** Fonts

Typefaces (e.g. Inter) and fonts (e.g. Inter Extra Light 12) can be
defined by =set-face-attribute=. There are three faces: =default=,
=fixed-pitch= (monospaced) and =variable-pitch= (proportionally
spaced). =fixed-pitch= is used in programming modes. Sometimes reading
prose or non-code texts is easier when displayed in a
=variable-pitch=.

The font configuration is handled by the ~fontaine~ package. Various
presets are defined in ~fontaine-presets~ and can be loaded with
~fontaine-set-preset~ (=C-c f=).

For now, I'll start with my font choices from earlier configurations.
Those are =Hack= as monospaced font and =Inter= as proportionally
spaced font.

#+begin_src emacs-lisp :tangle "init.el"
(use-package fontaine
  :ensure t
  :if (display-graphic-p)
  :hook
  ((after-init . fontaine-mode)
   (after-init . (lambda ()
                   (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular)))))
  :bind ("C-c f" . fontaine-set-preset)
  :config
  (setq fontaine-presets
        '((small
           :default-family "Hack"
           :default-height 100
           :variable-pitch-family "Hack")
          (regular)
          (medium
           :default-weight semilight
           :default-height 130
           :bold-weight extrabold)
          (large
           :inherit medium
           :default-height 150)
          (t
           :default-family "Hack"
           :default-weight regular
           :default-slant normal
           :default-height 120

           :fixed-pitch-family "Hack"
           :fixed-pitch-weight nil
           :fixed-pitch-slant nil
           :fixed-pitch-height 1.0

           :variable-pitch-family "Inter"
           :variable-pitch-weight nil
           :variable-pitch-slant nil
           :variable-pitch-height 1.0))))
#+end_src

~variable-pitch-mode~ makes the current buffer use a proportionately
spaced font. All buffers that load with ~text-mode~ will use these for
prose. Code e.g. Org source code blocks still use a monospaced font.
The font size can be adjusted on the fly with
~global-text-scale-adjust~ for all buffers.

#+begin_src emacs-lisp :tangle "init.el"
(use-package face-remap
  :ensure nil
  :hook (text-mode . variable-pitch-mode)
  :bind
  (("C-x C-=" . global-text-scale-adjust)
   ("C-x C-+" . global-text-scale-adjust)
   ("C-x C-0" . global-text-scale-adjust)))
#+end_src

** Icons

=nerd-icons.el= loads icons that can be used in various parts of the
interface. This package doesn't install any font files automatically.
The user must handle this step by invoking the command
~nerd-icons-install-fonts~.

#+begin_src emacs-lisp :tangle "init.el"
(use-package nerd-icons
  :ensure t)
#+end_src

** Auto Revert Buffers

Ensures that external changes to a file are updated in the buffer
holding the content of that file.

#+begin_src emacs-lisp :tangle "init.el"
(use-package autorevert
  :ensure nil
  :hook (after-init . global-auto-revert-mode)
  :config
  (setq auto-revert-verbose t))
#+end_src

** Delete Selected Text Upon Insertion of New Text

The sane way of working with text is to delete a selected text on
insertion of new text. Emacs appends the inserted text to the
selection by default.

#+begin_src emacs-lisp :tangle "init.el"
(use-package delsel
  :ensure nil
  :hook (after-init . delete-selection-mode))
#+end_src

** Display Date and Time

With ~display-time-mode~ enabled, the mode line contains the current
date and time. This is the only information needed from this function.
All other options are disabled.

#+begin_src emacs-lisp :tangle "init.el"
(use-package time
  :ensure nil
  :hook (after-init . display-time-mode)
  :config
  (setq display-time-format " %a %e %b, %H:%M %Z ")
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)
  (setq display-time-mail-directory nil)
  (setq display-time-mail-function nil)
  (setq display-time-use-mail-icon nil)
  (setq display-time-mail-string nil)
  (setq display-time-mail-face nil)
  (setq display-time-string-forms
        '((propertize
           (format-time-string display-time-format now)
           'face 'display-time-date-and-time
           'help-echo (format-time-string "%a %b %e, %Y" now))
          " ")))
#+end_src

** World Clock

As I work with people in different time zones, the function =M-x
world-clock= provides a handy overview of the time across different
regions of the world.

#+begin_src emacs-lisp :tangle "init.el"
(use-package time
  :ensure nil
  :commands (world-clock)
  :config
  (setq display-time-world-list t)
  (setq zoneinfo-style-world-list ; M-x shell RET timedatectl list-timezones
        '(("America/Los_Angeles" "Los Angeles")
          ("America/Vancouver" "Vancouver")
          ("Canada/Pacific" "Canada/Pacific")
          ("America/Chicago" "Chicago")
          ("Brazil/Acre" "Rio Branco")
          ("America/New_York" "New York")
          ("Canada/Atlantic" "Canada/Atlantic")
          ("Brazil/East" "Brasília")
          ("UTC" "UTC")
          ("Europe/Lisbon" "Lisbon")
          ("Europe/Brussels" "Brussels")
          ("Europe/Athens" "Athens")
          ("Asia/Riyadh" "Riyadh")
          ("Asia/Tehran" "Tehran")
          ("Asia/Tbilisi" "Tbilisi")
          ("Asia/Yekaterinburg" "Yekaterinburg")
          ("Asia/Kolkata" "Kolkata")
          ("Asia/Singapore" "Singapore")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Seoul" "Seoul")
          ("Asia/Tokyo" "Tokyo")
          ("Asia/Vladivostok" "Vladivostok")
          ("Australia/Brisbane" "Brisbane")
          ("Australia/Sydney" "Sydney")
          ("Pacific/Auckland" "Auckland")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z (%Z)	%A %d %B")
  (setq world-clock-buffer-name "*world-clock*")
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60))
#+end_src

** Laptop-specific Settings

My main computer is a laptop. It makes sense to keep an eye an
remaining battery while not being connected to power. Battery status
is shown in the mode line.

#+begin_src emacs-lisp :tangle "init.el"
(unless (directory-empty-p "/sys/class/power_supply/")
  (use-package battery
    :ensure nil
    :hook (after-init . display-battery-mode)
    :config
    (setq battery-mode-line-format
          (cond
           ((eq battery-status-function #'battery-linux-proc-acpi)
            "⏻%b%p%%,%d°C ")
           (battery-status-function
            "⏻%b%p%% ")))))
#+end_src

** Vertical Minibuffer Layout - ~vertico~

The default minibuffer layout displays completion candidates in a 2d
grid. I prefer only one dimension. ~vertico~ enables a vertical layout.

#+begin_src emacs-lisp :tangle "init.el"
(use-package vertico
  :ensure t
  :hook (after-init . vertico-mode)
  :config
  (setq vertico-scroll-margin 0)
  (setq vertico-count 5)
  (setq vertico-resize t)
  (setq vertico-cycle t))
#+end_src

** Annotations for Completion Candidates - ~marginalia~

Completion candidates in the minibuffer are displayed vertically in my
configuration. This leaves a lot of space to the right of them, which
is wasted.
~marginalia~ fills this space with context for the candidates. This is
very helpful when selecting functions and files or describing
variables.

#+begin_src emacs-lisp :tangle "init.el"
(use-package marginalia
  :ensure t
  :defer 1
  :config
  (setq marginalia-max-relative-age 0)
  (marginalia-mode 1))
#+end_src

** Mode Line

I consider the default mode line to be a bit cryptic and cluttered
with information that I do not need all the time, e.g. displaying a
lot of modes that are active in the buffer.
The mode line configured by [[https://protesilaos.com][Protesilaos Stavrou]] looks very minimal yet
informational, which I like.
I replicate most of his settings below.

#+begin_src emacs-lisp :tangle "init.el"
(use-package emacs
  :ensure nil
  :config
  (setq mode-line-compact nil)
  (setq mode-line-right-align-edge 'right-margin)
  (setq-default mode-line-format
                '("%e"
                  prot-modeline-buffer-status
                  prot-modeline-window-dedicated-status
                  prot-modeline-input-method
                  "  "
                  rrogg-modeline-buffer-identification
                  "  "
                  rrogg-modeline-major-mode
                  prot-modeline-process
                  "  "
                  prot-modeline-vc-branch
                  "  "
                  mode-line-format-right-align
                  "  "
                  prot-modeline-misc-info)))

;;; Mode line faces

(defgroup prot-modeline nil
  "Custom modeline that is stylistically close to the default."
  :group 'mode-line)

(defgroup prot-modeline-faces nil
  "Faces for my custom modeline."
  :group 'prot-modeline)

(defface prot-modeline-indicator-button nil
  "Generic face used for indicators that have a background.
Modify this face to, for example, add a :box attribute to all
relevant indicators (combines nicely with my `spacious-padding'
package).")

(defface prot-modeline-indicator-red-bg
  '((default :inherit (bold prot-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#aa1111" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#ff9090" :foreground "black")
    (t :background "red" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'prot-modeline-faces)

(defface prot-modeline-indicator-gray-bg
  '((default :inherit (bold prot-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#808080" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#a0a0a0" :foreground "black")
    (t :inverse-video t))
  "Face for modeline indicatovrs with a background."
  :group 'prot-modeline-faces)

(defface prot-modeline-indicator-green-bg
  '((default :inherit (bold prot-modeline-indicator-button))
    (((class color) (min-colors 88) (background light))
     :background "#207b20" :foreground "white")
    (((class color) (min-colors 88) (background dark))
     :background "#77d077" :foreground "black")
    (t :background "green" :foreground "black"))
  "Face for modeline indicators with a background."
  :group 'prot-modeline-faces)

;;; Buffer status

(defvar-local prot-modeline-buffer-status
    '(:eval
      (when (file-remote-p default-directory)
        (propertize " @ "
                    'face 'prot-modeline-indicator-red-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct for showing remote file name.")

;;; Dedicated window

(defvar-local prot-modeline-window-dedicated-status
    '(:eval
      (when (window-dedicated-p)
        (propertize " = "
                    'face 'prot-modeline-indicator-gray-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct for dedicated window indicator.")

;;; Input method

(defvar-local prot-modeline-input-method
    '(:eval
      (when current-input-method-title
        (propertize (format " %s " current-input-method-title)
                    'face 'prot-modeline-indicator-green-bg
                    'mouse-face 'mode-line-highlight)))
  "Mode line construct to report the multilingual environment.")

;;; Buffer name

(defun prot-modeline-buffer-identification-face ()
  "Return appropriate face or face list for `prot-modeline-buffer-identification'."
  (let ((file (buffer-file-name)))
    (cond
     ((and (mode-line-window-selected-p)
           file
           (buffer-modified-p))
      '(italic mode-line-buffer-id))
     ((and file
           (buffer-modified-p))
      'italic)
     ((mode-line-window-selected-p)
      'mode-line-buffer-id))))

(defun rrogg-modeline-buffer-name ()
  "Return buffer name, with read-only indicator if relevant."
  (let ((name (buffer-name)))
    (if buffer-read-only
        (format "%s %s" (char-to-string #xE0A2) name)
      name)))

(defun prot-modeline-buffer-name-help-echo ()
  "Return `help-echo' value for `rrogg-modeline-buffer-identification'."
  (concat
   (propertize (buffer-name) 'face 'mode-line-buffer-id)
   "\n"
   (propertize
    (or (buffer-file-name)
        (format "No underlying file.\nDirectory is: %s" default-directory))
    'face 'font-lock-doc-face)))

(defvar-local rrogg-modeline-buffer-identification
    '(:eval
      (propertize (rrogg-modeline-buffer-name)
                  'face (prot-modeline-buffer-identification-face)
                  'mouse-face 'mode-line-highlight
                  'help-echo (prot-modeline-buffer-name-help-echo)))
  "Mode line construct for identifying the buffer being displayed.
Propertize the current buffer with the `mode-line-buffer-id'
face.  Let other buffers have no face.")

;;; Major mode

(defun prot-modeline-major-mode-indicator ()
  "Return appropriate propertized mode line indicator for the major mode."
  (let ((indicator (cond
                    ((derived-mode-p 'text-mode) "§")
                    ((derived-mode-p 'prog-mode) "λ")
                    ((derived-mode-p 'comint-mode) ">_")
                    (t "◦"))))
    (propertize indicator 'face 'shadow)))

(defun prot-modeline-major-mode-name ()
  "Return capitalized `major-mode' without the -mode suffix."
  (capitalize (string-replace "-mode" "" (symbol-name major-mode))))

(defun prot-modeline-major-mode-help-echo ()
  "Return `help-echo' value for `prot-modeline-major-mode'."
  (if-let ((parent (get major-mode 'derived-mode-parent)))
      (format "Symbol: `%s'.  Derived from: `%s'" major-mode parent)
    (format "Symbol: `%s'." major-mode)))

(defvar-local rrogg-modeline-major-mode
     '(:eval
       (concat
        (prot-modeline-major-mode-indicator)
        " "
        (propertize (prot-modeline-major-mode-name)
         'mouse-face 'mode-line-highlight
         'help-echo (prot-modeline-major-mode-help-echo))))
  "Mode line construct for displaying major modes.")

;;; Processes

(defvar-local prot-modeline-process
    (list '("" mode-line-process))
  "Mode line construct for the running process indicator.")


;;; vc branch

(declare-function vc-git--symbolic-ref "vc-git" (file))

(defun prot-modeline--vc-branch-name (file backend)
  "Return capitalized VC branch name for FILE with BACKEND."
  (when-let ((rev (vc-working-revision file backend))
             (branch (or (vc-git--symbolic-ref file)
                         (substring rev 0 7))))
    (capitalize branch)))

(declare-function vc-git-working-revision "vc-git" (file))

(defvar prot-modeline-vc-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mode-line down-mouse-1] 'vc-diff)
    (define-key map [mode-line down-mouse-3] 'vc-root-diff)
    map)
  "Keymap to display on VC indicator.")

(defun prot-modeline--vc-help-echo (file)
  "Return `help-echo' message for FILE tracked by VC."
  (format "Revision: %s\nmouse-1: `vc-diff'\nmouse-3: `vc-root-diff'"
          (vc-working-revision file)))

(defun prot-modeline--vc-text (file branch &optional face)
  "Prepare text for Git controlled FILE, given BRANCH.
With optional FACE, use it to propertize the BRANCH."
  (concat
   (propertize (char-to-string #xE0A0) 'face 'shadow)
   " "
   (propertize branch
               'face face
               'mouse-face 'mode-line-highlight
               'help-echo (prot-modeline--vc-help-echo file)
               'local-map prot-modeline-vc-map)))

(defun prot-modeline--vc-details (file branch &optional face)
  "Return Git BRANCH details for FILE."
  (prot-modeline--vc-text file branch face))

(defvar prot-modeline--vc-faces
  '((added . vc-locally-added-state)
    (edited . vc-edited-state)
    (removed . vc-removed-state)
    (missing . vc-missing-state)
    (conflict . vc-conflict-state)
    (locked . vc-locked-state)
    (up-to-date . vc-up-to-date-state))
  "VC state faces.")

(defun prot-modeline--vc-get-face (key)
  "Get face from KEY in `prot-modeline--vc-faces'."
   (alist-get key prot-modeline--vc-faces 'up-to-date))

(defun prot-modeline--vc-face (file backend)
  "Return VC state face for FILE with BACKEND."
  (prot-modeline--vc-get-face (vc-state file backend)))

(defvar-local prot-modeline-vc-branch
    '(:eval
      (when-let* (((mode-line-window-selected-p))
                  (file (buffer-file-name))
                  (backend (vc-backend file))
                  (branch (prot-modeline--vc-branch-name file backend))
                  (face (prot-modeline--vc-face file backend)))
        (prot-modeline--vc-details file branch face)))
  "Mode line construct to return propertized VC branch.")

;;; Misc info

(defvar-local prot-modeline-misc-info
    '(:eval
      (when (mode-line-window-selected-p)
        mode-line-misc-info))
  "Mode line construct displaying `mode-line-misc-info'.
Specific to the current window's mode line.")


;;; Enable risky variables

(dolist (construct '(prot-modeline-buffer-status
                     prot-modeline-window-dedicated-status
                     prot-modeline-input-method
                     rrogg-modeline-buffer-identification
                     rrogg-modeline-major-mode
                     prot-modeline-process
                     prot-modeline-vc-branch
                     prot-modeline-misc-info))
  (put construct 'risky-local-variable t))
#+end_src

** Ediff

Comparing files can be done effectively with ~ediff~. Put the buffers
side-by-side instead of on top of eachother for better visibility of
the diffs.

#+begin_src emacs-lisp :tangle "init.el"
(use-package ediff
  :ensure nil
  :commands (ediff-buffers ediff-files ediff-buffers3 ediff-files3)
  :init
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Calendar

When prompting for a date, e.g. when scheduling a task, the Emacs
calendar is used to give an overview of the last, current and upcoming
month. The week column shows Sunday as first day of the week by
default, while Monday is what I want.

#+begin_src emacs-lisp :tangle "init.el"
(use-package calendar
  :ensure nil
  :commands (calendar)
  :config
  (setq calendar-mark-diary-entries-flag nil)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '( 24-hours ":" minutes
           (when time-zone (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "CEST (UTC+2h)")
  (setq calendar-daylight-time-zone-name "CET (UTC+1h)"))
#+end_src

***  Holidays

Information about German holidays is featured in the calendar, making
it easy to spot when Easter will be next year.

The list =calendar-holidays= contains all days of the year which I
don’t have be at work. To make them show up in the agenda, the line
=%%(org-calendar-holiday)= has to appear somewhere below a heading in
an org file included in the =org-agenda-files=.
I typically write this line to the =rrogg-org-agenda-settings-file=.

#+begin_src emacs-lisp :tangle "init.el"
(use-package holidays
  :ensure nil
  :config
  (setq calendar-holidays
        '((holiday-fixed 1 1 "Neujahr")
          (holiday-fixed 5 1 "Tag der Arbeit")
          (holiday-fixed 10 3 "Tag der Deutschen Einheit")
          (holiday-fixed 12 25 "1. Weihnachtstag")
          (holiday-fixed 12 26 "2. Weihnachtstag")
          (holiday-easter-etc  -2 "Karfreitag")
          (holiday-easter-etc  +1 "Ostermontag")
          (holiday-easter-etc +39 "Christi Himmelfahrt")
          (holiday-easter-etc +50 "Pfingstmontag")
          (holiday-easter-etc +60 "Fronleichnam")
          (holiday-fixed 11 1 "Allerheiligen"))))
#+end_src

*** Special Dates

There are also days during the year connected to a event or special
meaning. Those days are featured in the agenda but I usually have to
appear at work that day. Therefore they should be treated a little
different from actual holidays.

Org mode (specifically =holidays.el=) supports only one list of dates
to be shown in the agenda by default (dates defined in
=calendar-holidays=). By copying and editing the three functions
below, it is possible to include a second list for special days which
are not holidays in Germany.

To make them show up in the agenda, the line
=%%(rrogg-org-calendar-specialdate)= has to appear somewhere in an org
file included in the =org-agenda-files=.
I typically write this line to the =rrogg-org-agenda-settings-file=.

#+begin_src emacs-lisp :tangle "init.el"
(defun rrogg-org-calendar-specialdate ()
  "List of special dates, for Diary display in Org mode."
  (require 'holidays)
  (let ((hl (rrogg-calendar-check-specialdates org-agenda-current-date)))
    (and hl (mapconcat #'identity hl "; "))))

(defun rrogg-calendar-check-specialdates (date)
  "Check the list of special dates for any that occur on DATE.
DATE is a list (month day year).  This function considers the
special dates from the list `calendar-specialdates', and returns a list of
strings describing those special dates that apply on DATE, or nil if none do."
  (let ((displayed-month (calendar-extract-month date))
        (displayed-year (calendar-extract-year date))
        specialdate-list)
    (dolist (h (rrogg-calendar-specialdate-list) specialdate-list)
      (if (calendar-date-equal date (car h))
          (setq specialdate-list (append specialdate-list (cdr h)))))))

(defun rrogg-calendar-specialdate-list ()
  "Form the list of special dates that occur on dates in the calendar window.
The special dates are those in the list `calendar-specialdates'."
  (let (res h err)
    (sort
     (dolist (p rrogg-calendar-specialdates res)
       (if (setq h (if calendar-debug-sexp
                       (let ((debug-on-error t))
                         (eval p))
                     (condition-case err
                         (eval p)
                       (error
                        (display-warning
                         'specialdays
                         (format "Bad specialdate list item: %s\nError: %s\n"
                                 p err)
                         :error)
                        nil))))
           (setq res (append h res))))
     'calendar-date-compare)))

(setq rrogg-calendar-specialdates
      '((holiday-float 5 0 2 "Muttertag")
        (holiday-float 6 0 3 "Vatertag")
        (holiday-float 12 0 -4 "1. Advent" 24)
        (holiday-float 12 0 -3 "2. Advent" 24)
        (holiday-float 12 0 -2 "3. Advent" 24)
        (holiday-float 12 0 -1 "4. Advent" 24)
        (holiday-fixed 12 24 "Heiligabend")
        (holiday-fixed 1 6 "Heilige Drei Könige")
        (holiday-easter-etc -52 "Weiberfastnacht")
        (holiday-easter-etc -50 "Karnevalssamstag")
        (holiday-easter-etc -49 "Karnevalssonntag")
        (holiday-easter-etc -48 "Rosenmontag")
        (holiday-easter-etc -47 "Veilchendienstag")
        (holiday-easter-etc -46 "Aschermittwoch")
        (holiday-easter-etc -3 "Gründonnerstag")
        (holiday-easter-etc   0 "Ostersonntag")
        (holiday-easter-etc +49 "Pfingstsonntag")
        (holiday-fixed 8 15 "Mariae Himmelfahrt")
        (holiday-fixed 11 11 "Martinstag")
        (holiday-fixed 11 11 "Elfter im Elften")
        (holiday-float 11 3 1 "Buss- und Bettag" 16)
        (holiday-float 11 0 1 "Totensonntag" 20)))
#+end_src

*** Solar Calendar

Emacs can calculate the time of sunrise, sundown and also other events
based on the position of the sun. In order to ensure that this
calculations are correct, latitude, longitude and location name need
to be adjusted to the current position on earth.

#+begin_src emacs-lisp :tangle "init.el"
(use-package solar
  :config
  (setq calendar-latitude [51 26 north]) ; Not my actual coordinates
  (setq calendar-longitude [6 45 east]))
#+end_src

Those solar events shall be categorized independently from other
calendar entries. This gives free choice on if and how this gets
integrated into the agenda.

Similar to the special dates solar dates show up in the agenda by
including the line =%%(rrogg-org-calendar-solar)= somewhere in one of
the =org-agenda-files=.
I typically write this line to the =rrogg-org-agenda-settings-file=.

#+begin_src emacs-lisp :tangle "init.el"
(defun rrogg-org-calendar-solar ()
  "List of solar dates, for Diary display in Org mode."
  (require 'holidays)
  (let ((hl (rrogg-calendar-check-solar org-agenda-current-date)))
    (and hl (mapconcat #'identity hl "; "))))

(defun rrogg-calendar-check-solar (date)
  "Check the list of solar for any that occur on DATE.
DATE is a list (month day year).  This function considers the
special dates from the list `calendar-solar', and returns a list of
strings describing those solar that apply on DATE, or nil if none do."
  (let ((displayed-month (calendar-extract-month date))
        (displayed-year (calendar-extract-year date))
        solar-list)
    (dolist (h (rrogg-calendar-solar-list) solar-list)
      (if (calendar-date-equal date (car h))
          (setq solar-list (append solar-list (cdr h)))))))

(defun rrogg-calendar-solar-list ()
  "Form the list of solar that occur on dates in the calendar window.
The solar are those in the list `calendar-solar'."
  (let (res h err)
    (sort
     (dolist (p rrogg-calendar-solar res)
       (if (setq h (if calendar-debug-sexp
                       (let ((debug-on-error t))
                         (eval p))
                     (condition-case err
                         (eval p)
                       (error
                        (display-warning
                         'solar
                         (format "Bad solar list item: %s\nError: %s\n"
                                 p err)
                         :error)
                        nil))))
           (setq res (append h res))))
     'calendar-date-compare)))

(setq rrogg-calendar-solar
      '((holiday-sexp calendar-daylight-savings-starts
	                  (format "Beginn der Sommerzeit – die Uhr wird um eine Stunde vorgestellt -> %s"
		                      (solar-time-string
			                   (/ calendar-daylight-savings-starts-time . #1=((float 60)))
			                   calendar-standard-time-zone-name)))
        (holiday-sexp calendar-daylight-savings-ends
	                  (format "Ende der Sommerzeit – die Uhr wird um eine Stunde zurückgestellt -> %s"
		                      (solar-time-string
			                   (/ calendar-daylight-savings-ends-time . #1#)
			                   calendar-daylight-time-zone-name)))))
#+end_src

** Completion Styles

#+begin_src emacs-lisp :tangle "init.el"
(use-package minibuffer
  :ensure nil
  :config
  (setq completion-styles '(basic substring initials flex orderless))
  (setq completion-category-overrides
        '((file (styles . (basic partial-completion orderless))))))
#+end_src

*** ~orderless~ Completion Style

Some key bindings need to be changed:
- =SPC= should never complete as it is used it for ~orderless~ groups.
- The =?= is a regexp construct.

#+begin_src emacs-lisp :tangle "init.el"
(use-package orderless
  :ensure t
  :demand t
  :after minibuffer
  :config
  (setq orderless-matching-styles '(orderless-prefixes orderless-regexp))
  :bind ( :map minibuffer-local-completion-map
          ("SPC" . nil)
          ("?" . nil)))
#+end_src

** Org-mode

*** General Settings

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :init
  (setq org-directory (expand-file-name "~/org/"))
  :config
  (setq org-ellipsis "↴")
  (setq org-cycle-separator-lines 0)
  (setq org-read-date-prefer-future 'time)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-block-delimiter-line t))

(setq rrogg-org-agenda-settings-file (concat org-directory "agenda_settings.org"))
#+end_src

*** Org Todo

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :config
  (setq org-todo-keywords
        '((sequence "NEXT(n)" "WAIT(w@)" "CALL(c)" "SITE(s)" "PLAN(p)" "HOLD(h@)" "|" "CANC(C@)" "DONE(d!)")))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t))
#+end_src

*** Org Tags

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :config
  (setq org-tag-alist nil)
  (setq org-auto-align-tags nil)
  (setq org-tags-column 0))
#+end_src

*** Org Links

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :bind
  ( :map global-map
    ("C-c l" . org-store-link))
  :config
  (setq org-link-context-for-files t)
  (setq org-link-keep-stored-after-insertion nil)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

*** Org Capture

#+begin_src emacs-lisp :tangle "init.el"
(use-package org-capture
  :ensure nil
  :bind ("C-c c" . org-capture)
  :config
  (setq org-capture-templates `(("t" "Task" entry
                                 (file rrogg-org-default-refile-file)
                                 ,(concat "* NEXT %^{Title}\n"
                                          ":PROPERTIES:\n"
                                          ":CREATED: %U\n"
                                          ":END:\n\n"
                                          "%a\n%i%?")
                                 :empty-lines 1)
                                ("c" "Call" entry
                                 (file rrogg-org-default-refile-file)
                                 ,(concat "* CALL %^{Title}\n"
                                          ":PROPERTIES:\n"
                                          ":CREATED: %U\n"
                                          ":END:\n\n"
                                          "%a\n%i%?")
                                 :empty-lines 1))))
#+end_src

*** Org Logging

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :config
  (setq org-log-refile 'time)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil))
#+end_src

*** Org Refile

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :config
  (setq org-refile-targets
        '((rrogg-org-refile-targets . (:maxlevel . 9))
          (nil . (:maxlevel . 9))))
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t))

(setq rrogg-org-default-refile-file (concat org-directory "refile.org"))
(setq rrogg-org-refile-targets (append
                                (list rrogg-org-default-refile-file)
                                (directory-files-recursively (concat org-directory "private") "\\.org$")
                                (directory-files-recursively (concat org-directory "crosscontrol") "\\.org$")))
#+end_src

*** Org Agenda

#+begin_src emacs-lisp :tangle "init.el"
(setq rrogg-org-agenda-files (append
                              rrogg-org-refile-targets
                              (list rrogg-org-agenda-settings-file)))
(setq rrogg-org-work-agenda-files (append
                                   (list rrogg-org-default-refile-file)
                                   (directory-files-recursively (concat org-directory "crosscontrol") "\\.org$")
                                   (list rrogg-org-agenda-settings-file)))
(setq rrogg-org-private-agenda-files (append
                                   (list rrogg-org-default-refile-file)
                                   (directory-files-recursively (concat org-directory "private") "\\.org$")
                                   (list rrogg-org-agenda-settings-file)))

(use-package org-agenda
  :ensure nil
  :bind ("C-c a" . org-agenda)
  :config
  (setq org-agenda-files rrogg-org-agenda-files)
  (setq org-agenda-format-date #'prot-org-agenda-format-date-aligned)
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-category-icon-alist
      '(("\\(Holiday\\|Vacation\\)" "~/templates_labels/icons/holiday.png" nil nil :ascent center)
        ("Anniv." "~/templates_labels/icons/anniversary.png" nil nil :ascent center)
        ("Spec. Date" "~/templates_labels/icons/specialdate.png" nil nil :ascent center)
        ("Time" "~/templates_labels/icons/time.png" nil nil :ascent center)
        ("Marriage" "~/templates_labels/icons/marriage.gif" nil nil :ascent center)
        ("Love" "~/templates_labels/icons/love.png" nil nil :ascent center)
        ("Mourning" "~/templates_labels/icons/mourning.png" nil nil :ascent center)
        (".*" '(space . (:width (16))))))
  (setq org-agenda-dim-blocked-tasks nil))

(defun prot-org-agenda-format-date-aligned (date)
  "Format a DATE string for display in the daily/weekly agenda.
This function makes sure that dates are aligned for easy reading.

Slightly tweaked version of `org-agenda-format-date-aligned' that
produces dates with a fixed length."
  (require 'cal-iso)
  (let* ((dayname (calendar-day-name date t))
         (day (cadr date))
         (day-of-week (calendar-day-of-week date))
         (month (car date))
         (monthname (calendar-month-name month t))
         (year (nth 2 date))
         (iso-week (org-days-to-iso-week
                    (calendar-absolute-from-gregorian date)))
         ;; (weekyear (cond ((and (= month 1) (>= iso-week 52))
         ;;                  (1- year))
         ;;                 ((and (= month 12) (<= iso-week 1))
         ;;                  (1+ year))
         ;;                 (t year)))
         (weekstring (if (= day-of-week 1)
                         (format " (W%02d)" iso-week)
                       "")))
    (format "%s %2d %s %4d%s"
            dayname day monthname year weekstring)))


#+end_src


**** Agenda Views

How the agenda is rendered is of course customizable.
Agenda views can be saved to the =org-agenda-custom-commands= list and will be
presented as an option when calling the agenda dispatcher with =C-c a=.

The agenda setup is drawing heavily from the amazing work of [[http://doc.norang.ca/org-mode.html][Bernt Hansen]].

#+begin_src emacs-lisp :tangle "init.el" :noweb yes
(setq org-agenda-custom-commands '())
(add-to-list 'org-agenda-custom-commands
             <<my-agenda>>)
(add-to-list 'org-agenda-custom-commands
             <<my-work-agenda>>)
(add-to-list 'org-agenda-custom-commands
             <<my-private-agenda>>)
#+end_src

***** My Agenda

The main agenda is a composition of multiple agenda commands. The list syntax
for a composite agenda buffer is
=(key desc (cmd1 cmd2 ...) general-settings-for-whole-set files)=.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda
'(<<my-agenda-key-desc>>
  (<<my-agenda-cmd-agenda>>
   <<my-agenda-cmd-refile>>
   <<my-agenda-cmd-stuck-project>>
   <<my-agenda-cmd-project>>
   <<my-agenda-cmd-project-next>>
   <<my-agenda-cmd-standalone>>
   <<my-agenda-cmd-project-plan>>
   <<my-agenda-cmd-waiting>>))
#+end_src

The agenda can be called by pressing =key= when on the agenda dispatcher. The
complete key command is =C-c a SPC=.
A description of the view is passed to the agenda dispatcher via =desc=.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-key-desc
" " "My Agenda"
#+end_src

****** Daily/Weekly Agenda

The daily/weekly agenda is at the top of the buffer.
It is spawned by a non-matching agenda command with syntax =(cmd "" settings)=.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-agenda
(agenda "")
#+end_src

****** Headings to Refile

Headings that have been captured but still need to be refiled, appear below the
daily/weekly agenda.
There is an agenda command =tags= that matches tags/properties/todos in all
agenda files. General syntax for matching agenda commands is =(cmd "match"
settings files)=.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-refile
(<<my-agenda-cmd-refile-cmd-match>>
      <<my-agenda-cmd-refile-settings>>)
#+end_src

All of the headings to be shown here have a tag =:REFILE:= assigned to them, so
it will search for this tag.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-refile-cmd-match
tags "REFILE"
#+end_src

The way the matching headings are presented can be adjusted using settings.
The header of the refile section is changed.
Subtrees of a match are skipped in order to prevent a potentially very long list
of matches.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-refile-settings
((org-agenda-overriding-header "Headings to Refile")
 (org-tags-match-list-sublevels nil))
#+end_src

****** Stuck Projects

A stuck project is one that does not have any subtask (or subproject) that can
be worked on right now. To unstuck a project, at least one of its tasks has to
be in a =NEXT= state.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-stuck-project
(<<my-agenda-cmd-stuck-project-cmd-match>>
      <<my-agenda-cmd-stuck-project-settings>>)
#+end_src

Exclude projects that are on hold or cancelled.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-stuck-project-cmd-match
tags-todo "/!-HOLD-CANC-PLAN"
#+end_src

Projects can't be found with todo-states alone, because I don't have a dedicated
state for them.
Therefore the function [[id:8dc94898-0f38-4aee-b1be-db569f3879a3][=hansen-skip-non-stuck-projects=]] is called, which decides
which headings to skip for being displayed in this section on the agenda.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-stuck-project-settings
((org-agenda-overriding-header "Stuck Projects")
 (org-agenda-skip-function 'hansen-skip-non-stuck-projects))
#+end_src

****** Projects

Projects that can be worked on are listed in this section. Those projects have
at least one task in =NEXT= state, that is unblocked and can be worked on.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-project
(<<my-agenda-cmd-project-cmd-match>>
      <<my-agenda-cmd-project-settings>>)
#+end_src

Cancelled and on-hold projects are not displayed.
Also projects still in planning phase are excluded.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-cmd-match
tags-todo "/!-HOLD-CANC-PLAN"
#+end_src

The skip function that identifies projects is [[id:6faa31dc-43a0-447a-88d0-fffbe14a3cb0][=hansen-skip-non-projects=]].

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-settings
((org-agenda-overriding-header "Projects")
 (org-tags-match-list-sublevels 'indented)
 (org-agenda-skip-function 'hansen-skip-non-projects))
#+end_src

****** Project Next Tasks

Tasks in =NEXT= state, that move a project towards its goal, are listed in this
section. If a task is displayed here, it can be worked on right away.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-project-next
(<<my-agenda-cmd-project-next-cmd-match>>
      <<my-agenda-cmd-project-next-settings>>)
#+end_src

Given by the section name, only =NEXT= stated are valid.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-next-cmd-match
tags-todo "/!-HOLD-CANC-WAIT-CALL-SITE"
#+end_src

[[id:b5c5c889-06c7-46b2-a89d-32327610f5a9][Standalone tasks]] are excluded from this section. Those are tasks that are
independent from a project and have their own section.
The skip function is [[id:61741020-afa3-43ed-8db2-ba936490c0cd][=hansen-skip-projects-standalone=]].

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-next-settings
((org-agenda-overriding-header "Project Next Tasks")
 (org-agenda-skip-function 'hansen-skip-projects-standalone))
#+end_src

****** Standalone Tasks
:PROPERTIES:
:ID:       b5c5c889-06c7-46b2-a89d-32327610f5a9
:END:

Independent tasks, meaning tasks that are not contributing towards a common goal
within a project, are displayed separately.
All headings under this section must have a todo-state. Therefore the agenda
command =tags-todo= is fitting, because it automatically skips non-task
headings.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-standalone
(<<my-agenda-cmd-standalone-cmd-match>>
      <<my-agenda-cmd-standalone-settings>>)
#+end_src

All tasks are matched against the following todo-states or tags:
- Skip tasks tagged =:REFILE:= - those are gathered in section =Headings to
  Refile=.
- Skip =CANCELLED= tasks - those are gathered elsewhere.
- Skip =CALL= tasks - those are only shown in the agenda.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-standalone-cmd-match
tags-todo "-REFILE/!-CANC-CALL-WAIT-SITE"
#+end_src

The remaining candidates to display still contain projects and project tasks.
Those need to be skipped. A function can be assigned to
=org-agenda-skip-function= in order to do this step.
The skip function should return =nil= in case the current match should not be
skipped. In case the match should be skipped, the return value must be a
position from which the search for the next match should be continued.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-standalone-settings
((org-agenda-overriding-header "Standalone Tasks")
 (org-agenda-skip-function 'hansen-skip-project-tasks))
#+end_src

****** Planned Projects

Projects that are not completely planned and need some more thought before they
can be started have their own section. I can't work on tasks for those projects
right now. But still, I want to have them visible in order to drive me to
complete the planning.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-project-plan
(<<my-agenda-cmd-project-plan-cmd-match>>
      <<my-agenda-cmd-project-plan-settings>>)
#+end_src

All projects to be considered in this section are in =PLANNING= state.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-plan-cmd-match
tags-todo "/!-HOLD-CANC+PLAN"
#+end_src

The skip function is the same as for regular projects
([[id:6faa31dc-43a0-447a-88d0-fffbe14a3cb0][=hansen-skip-non-projects=]]).

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-project-plan-settings
((org-agenda-overriding-header "Planned Projects")
 (org-agenda-skip-function 'hansen-skip-non-projects))
#+end_src

****** Waiting and On-Hold Tasks

All tasks that I am waiting on or that I put on hold for now, are listed
here. This sections prevents that those tasks are forgotten and acts as a
reminder to reinvestigate why they are blocked.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-agenda-cmd-waiting
(<<my-agenda-cmd-waiting-cmd-match>>
      <<my-agenda-cmd-waiting-settings>>)
#+end_src

=WAITING= and =HOLD= states are considered to be shown here.

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-waiting-cmd-match
tags-todo "/!-CANC+WAIT|+HOLD"
#+end_src

Everything that is not a task will be skipped by [[id:25074132-89d0-4e89-98bd-be8e34637b75][=hansen-skip-non-tasks=]].

#+begin_src emacs-lisp :tangle no :noweb-ref my-agenda-cmd-waiting-settings
((org-agenda-overriding-header "Waiting and On-Hold Tasks")
 (org-agenda-skip-function 'hansen-skip-non-tasks))
#+end_src

***** My Work Agenda

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-work-agenda
'(<<my-work-agenda-key-desc>>
  (<<my-agenda-cmd-agenda>>
   <<my-agenda-cmd-refile>>
   <<my-agenda-cmd-stuck-project>>
   <<my-agenda-cmd-project>>
   <<my-agenda-cmd-project-next>>
   <<my-agenda-cmd-standalone>>
   <<my-agenda-cmd-project-plan>>
   <<my-agenda-cmd-waiting>>)
  ((org-agenda-files rrogg-org-work-agenda-files))
  ((org-agenda-time-grid
    '((daily today require-timed)
      (0900 1000 1100 1200 1300
	    1400 1500 1600 1700)
      " ....." "-----------------"))))
#+end_src

The agenda can be called by pressing =key= when on the agenda dispatcher. The
complete key command is =C-c a w=.
A description of the view is passed to the agenda dispatcher via =desc=.

#+begin_src emacs-lisp :tangle no :noweb-ref my-work-agenda-key-desc
"w" "My Work Agenda"
#+end_src

***** My Private Agenda

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref my-private-agenda
'(<<my-private-agenda-key-desc>>
  (<<my-agenda-cmd-agenda>>
   <<my-agenda-cmd-refile>>
   <<my-agenda-cmd-stuck-project>>
   <<my-agenda-cmd-project>>
   <<my-agenda-cmd-project-next>>
   <<my-agenda-cmd-standalone>>
   <<my-agenda-cmd-project-plan>>
   <<my-agenda-cmd-waiting>>)
  ((org-agenda-files rrogg-org-private-agenda-files)))
#+end_src

The agenda can be called by pressing =key= when on the agenda dispatcher. The
complete key command is =C-c a p=.
A description of the view is passed to the agenda dispatcher via =desc=.

#+begin_src emacs-lisp :tangle no :noweb-ref my-private-agenda-key-desc
"p" "My Private Agenda"
#+end_src

***** Functions for Agenda Building

****** Skip Functions

These functions are used for skipping headings that have been matched during
creating of the agenda.
The expected return values are:
- =position=: In case of identification of a heading that should be skipped, the
  position from where to continue is the return value.
- =nil=: In case of a heading that should not be skipped.

******* Skip Projects and Project Tasks

First of, =save-restriction= saves the current buffer’s restrictions when it is
entered and restores them when it is exited.
Then potential narrowing of the buffer gets removed with =widen=.
A local binding for the variable =end-of-subtree= is created using =let=. This
binding will only be in effect within the body of the =let= statement.
The variable =end-of-subtree= holds the position of the end of the subtree
visited by =org-end-of-subtree=. This is possible to do so because it is
encapsulated in a =save-excursion= special form. This saves point and current
buffer, executes =org-end-of-subtree= and restores the previous state of point
and buffer.
The body of =let= is a conditional control structure =cond=. The body of the
first condition successfully is returned. If non succeeds the return value is
=nil=.
The headings will be checked against [[id:4564159d-6e4b-43a2-9ec5-7650d25501c7][=hansen-is-project-p=]]. If this functions
returns =t=, the complete subtree will be skipped.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-skip-project-tasks ()
  "Skip org-headings that are part of a project.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t))))
      (cond
       ((hansen-is-project-p)
        end-of-subtree)
       (t
        nil)))))
#+end_src

******* Skip Non-Projects

This function follows the same structure as [[id:4743e8ba-4c6c-459b-9c26-a669ad843dc8][=hansen-skip-project-tasks=]].
Headings will be checked against [[id:10e7b990-3bb5-4a81-8015-d0b7c59fa95c][=hansen-is-stuck-project-p=]] and
[[id:4564159d-6e4b-43a2-9ec5-7650d25501c7][=hansen-is-project-p=]].

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-skip-non-projects ()
  "Skip org-headings that are not projects.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t))))
      (cond
       ((hansen-is-stuck-project-p)
        end-of-subtree)
       ((hansen-is-project-p)
        nil)
       (t
        end-of-subtree)))))
#+end_src

******* Skip Non-Project Tasks

Similar structure to the previous skip functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-skip-non-project-tasks ()
  "Skip org-headings that are projects, subproject tasks or standalone tasks.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
          (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((hansen-is-project-p)
        next-headline)
       ((and (hansen-is-project-task-p)
             (equal (org-get-todo-state) "NEXT"))
        end-of-subtree)
       ((not (hansen-is-project-task-p))
        end-of-subtree)
       (t
        nil)))))
#+end_src

******* Skip Projects and Standalone Tasks

Similar structure to the previous skip functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-skip-projects-standalone ()
  "Skip org-headings that are projects or standalone tasks.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((hansen-is-project-p)
        next-headline)
       ((and (hansen-is-task-p) (not (hansen-is-project-task-p)))
        next-headline)
       ((hansen-is-project-planning-task-p)
        next-headline)
       (t
        nil)))))
#+end_src

******* Skip Non-Stuck-Projects

Similar structure to the previous skip functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-skip-non-stuck-projects ()
  "Skip org-headings that are projects and not stuck.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((hansen-is-project-planning-task-p)
        next-headline)
       ((hansen-is-project-hold-task-p)
        next-headline)
       ((hansen-is-stuck-project-p)
        nil)
       (t
        next-headline)))))
#+end_src

******* Skip Non-Tasks

Similar structure to the previous skip functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-skip-non-tasks ()
  "Skip org-headings that are projects or subprojects.
If heading should be skipped, return position of end of subtree to continue searching.
Return nil in case the heading should not be skipped."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((hansen-is-task-p)
        nil)
       (t
        next-headline)))))
#+end_src

****** Identification Functions

The following functions are used to identify what kind of org-heading or task an
entry is.
Return value is either =t= or =nil=.

******* Identify Projects

Current buffer's restrictions are saved via =save-restriction= and restored when
the function is exited.
Then potential narrowing of the buffer gets removed with =widen=.
Three local bindings for variables are needed in order to determine if the tasks
is a project:
- =end-of-subtree=: Holds the position of the end of the subtree visited by
  =org-end-of-subtree=.
- =is-task=: Checks if org-heading has a todo keyword, returns boolean.
- =has-subtask=: Boolean, default value is =nil=.
Because this function examines the org-headings coming after the current one,
point is moved one line forward.
The following =while= control loop searches for the next org-heading and sets
the variable =has-subtask= to =t= if the org-heading contains a todo keyword.
The return value is =t= if both of =is-task= and =has-subtask= are =t=.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-is-project-p ()
  "A task with a subtask is a project."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
          (is-task (member (org-get-todo-state) org-todo-keywords-1))
          (has-subtask))
      (save-excursion
        (forward-line 1)
        (while (and (< (point) end-of-subtree)
                    (re-search-forward "^\*+ " end-of-subtree t)
                    (not has-subtask))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-task has-subtask))))
#+end_src

******* Identify Stuck Projects

Similar structure to the previous identify function.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-is-stuck-project-p ()
  "A task without a subtask in NEXT state is a stuck project."
  (save-restriction
    (widen)
    (if (hansen-is-project-p)
        (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
              (has-next-subtask))
          (save-excursion
            (forward-line 1)
            (while (and (< (point) end-of-subtree) (re-search-forward "^\*+ NEXT\\|CALL " end-of-subtree t) (not has-next-subtask))
              (setq has-next-subtask t)))
          (if has-next-subtask
              nil
            t))
      nil)))
#+end_src

******* Identify Tasks

Similar structure to the previous identify functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-is-task-p ()
  "Check if task has no subtask."
  (save-restriction
    (widen)
    (let ((end-of-subtree (save-excursion (org-end-of-subtree t)))
          (is-task (member (org-get-todo-state) org-todo-keywords-1))
          (has-subtask))
      (save-excursion
        (forward-line 1)
        (while (and (< (point) end-of-subtree)
                    (re-search-forward "^\*+ " end-of-subtree t)
                    (not has-subtask))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-task (not has-subtask)))))
#+end_src

******* Identify Project Task

Similar structure to the previous identify functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-is-project-task-p ()
  "Check if task is part of a project."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (save-excursion
        (hansen-find-parent-task)
        (if (equal (point) parent-task)
            nil
          t)))))
#+end_src

******* Identify Project Planning Task

Similar structure to the previous identify functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-is-project-planning-task-p ()
  "Check if task is part of a project in planning state."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (save-excursion
        (hansen-find-parent-planning-task)
        (if (equal (point) parent-task)
            nil
          t)))))
#+end_src
******* Identify Project Hold Task

Similar structure to the previous identify functions.

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-is-project-hold-task-p ()
  "Check if task is part of a project in hold state."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (save-excursion
        (hansen-find-parent-hold-task)
        (if (equal (point) parent-task)
            nil
          t)))))
#+end_src

****** Search Functions

The following functions are used to search for specific org-headings or tasks.
Return value is the position of point at the beginning of the heading or =nil=.

******* Find Parent Task

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-find-parent-task ()
  "Move point to the parent task of a task."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (while (org-up-heading-safe)
        (when (member (org-get-todo-state) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task))))
#+end_src

******* Find Parent Planning Task

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-find-parent-planning-task ()
  "Move point to the parent planning task of a task."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (while (org-up-heading-safe)
        (when (equal (org-get-todo-state) "PLANNING")
          (setq parent-task (point))))
      (goto-char parent-task))))
#+end_src

******* Find Parent Hold Task

#+begin_src emacs-lisp :tangle "init.el"
(defun hansen-find-parent-hold-task ()
  "Move point to the parent hold task of a task."
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading t) (point))))
      (while (org-up-heading-safe)
        (when (equal (org-get-todo-state) "HOLD")
          (setq parent-task (point))))
      (goto-char parent-task))))
#+end_src

*** Org Code Block Settings

Source blocks can be edited in a window that uses the mode for the
programming language of the block. This window will be spawned on top
of the current window leaving the window configuration intact. The
source code will be fontified and indented in the code block as
expected for the language of the code.
Source code block templates are defined in
~org-structure-template-alist~ and can be inserted via the function
~org-insert-structure-template~ (=C-c C-,=).

#+begin_src emacs-lisp :tangle "init.el"
(use-package org
  :ensure nil
  :config
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)
  (setq org-structure-template-alist
        '(("s" . "src")
          ("e" . "src emacs-lisp")
          ("t" . "src emacs-lisp :tangle FILENAME")
          ("x" . "example")
          ("X" . "export")
          ("q" . "quote"))))
#+end_src
