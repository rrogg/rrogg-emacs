#+title: rrogg-emacs - My GNU Emacs Configuration
#+startup: content indent

* The Early Initialisation of Emacs (=early-init.el=)

** Maximize Frame

The Emacs frame is maximized at all times to make use of every pixel
on the screen.

#+begin_src emacs-lisp :tangle "early-init.el"
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Hide Welcome Screen and Empty =*scratch*=

Emacs shows a splash screen at startup from which one can easily get
to the tutorial. While helpful in the beginning, this screen gets
abdicable with time. Therefore it's disabled.
Emacs also automatically loads a buffer called =*scratch*=, which
serves as a place to try out emacs lisp code or to type out some
ideas. This is very helpful as one doesn't have to think about
creating a new file for every unrelated thought. The welcome message
isn't needed, so it's disabled.

#+begin_src emacs-lisp :tangle "early-init.el"
(setq inhibit-startup-screen t
      initial-scratch-message nil)
#+end_src

** Disable GUI Bar Components

Display no GUI components other than the =modline=.

#+begin_src emacs-lisp :tangle "early-init.el"
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

** Initialise the Package Cache

Initialise installed packages and make them available when Emacs
starts. This must be set in the =early-init.el= in order to make the
packages available before reading the =init.el=. 

#+begin_src emacs-lisp :tangle "early-init.el"
(setq package-enable-at-startup t)
#+end_src

** Avoid the Initial Flash of Light

The default Emacs theme that is loaded initially is white.
This causes a "flash of light" if a dark theme is selected by the
user, as the basic colour values at startup are still loaded first.
The funtions below will hardcode the background colour to black and
then load the theme the user wants.
This function is from the config of [[https://protesilaos.com][Protesilaos Stavrou]].

#+begin_src emacs-lisp :tangle "early-init.el"
(defun prot-emacs-re-enable-frame-theme (_frame)
  "Re-enable active theme, if any, upon FRAME creation.
Add this to `after-make-frame-functions' so that new frames do
not retain the generic background set by the function
`prot-emacs-avoid-initial-flash-of-light'."
  (when-let ((theme (car custom-enabled-themes)))
    (enable-theme theme)))

(defun prot-emacs-avoid-initial-flash-of-light ()
  "Avoid flash of light when starting Emacs, if needed.
New frames are instructed to call `prot-emacs-re-enable-frame-theme'."
  (setq mode-line-format nil)
  (set-face-attribute 'default nil :background "#000000" :foreground "#ffffff")
  (set-face-attribute 'mode-line nil :background "#000000" :foreground "#ffffff" :box 'unspecified)
  (add-hook 'after-make-frame-functions #'prot-emacs-re-enable-frame-theme))

(prot-emacs-avoid-initial-flash-of-light)
#+end_src

* The Main Initialisation of Emacs (=init.el=)

** Backups and Lockfiles

Emacs creates backups of files automatically by default. I like to
decide what gets backuped where on my own.
Files don't need to be locked to prevent external programs from
editing these, because I should be aware of it and actually want this
to happen.

#+begin_src emacs-lisp :tangle "init.el"
(setq make-backup-files nil)
(setq create-lockfiles nil)
#+end_src

** Text Manipulation and Language

*** The =TAB= Key: Indentation and Completion

The =TAB= key tries to indent the current line or paragraph. If the
text can't be indented, it will try to do a completion at
point. ~tab-always-indent~ is set to accomplish this.
Exceptions for completing are controlled by ~tab-first-completion~.
A =TAB= shall always be a number of spaces, defined by ~tab-width~,
and never an actual tab.

#+begin_src emacs-lisp :tangle "init.el"
(use-package emacs
  :ensure nil
  :demand t
  :config
  (setq tab-always-indent 'complete)
  (setq tab-first-completion 'word-or-paren-or-punct)
  (setq-default tab-width 4
                indent-tabs-mode nil))
#+end_src

*** Wrap Lines at a Reasonable Width

Long lines of text are wrapped at a width of 70 characters to improve
readability. In order to leave long code lines untouched, automatic
line wrap is only active in =text-mode= and modes which inherit from
it, like =org-mode=.
Emacs default is that a sentence ends with a double space. One space
after the end of a sentence, which is marked by a period, feels more
natural for me.

#+begin_src emacs-lisp :tangle "init.el"
(use-package text-mode
  :ensure nil
  :mode "\\`\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)\\'"
  :hook
  (text-mode . turn-on-auto-fill)
  :config
  (setq-default fill-column 70 )
  (setq sentence-end-double-space nil)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t))
#+end_src

** git

*** How to Write a Good Commit Message

A good commit message follows [[https://chris.beams.io/posts/git-commit/][7 rules]]:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs. how

For example:

#+begin_example
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
#+end_example

*** magit

=magit= is a superb interface to =git=.

All stylistic rules can be taken care of by =magit=. It will color
characters on the summary line exceeding length of 50 red and does the
same for the second line, which should be blank. The body of the
message is wrapped at length 70.

#+begin_src emacs-lisp :tangle "init.el"
(use-package magit
  :ensure t
  :bind ("C-c g" . magit-status)
  :hook (git-commit-setup . rrogg-git-commit-setup)
  :init
  (setq magit-define-global-key-bindings nil)
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq git-commit-fill-column 70)
  (defun rrogg-git-commit-setup()
    (insert "#1. Capitalize the subject line
#2. Do not end the subject line with a period
#3. Use the present tense imperative mood in the subject line and body
#4. Use the body to explain what and why vs. how
#-----------------------------------------------
#If applied, this commit will …
")))
#+end_src

** Save Commands Across Sessions

Emacs doesn't have a persistent command history by default. The
build-in history gets resetted with every new Emacs session. The
package =savehist= implements a session independent history.

#+begin_src emacs-lisp :tangle "init.el"
(use-package savehist
  :ensure nil
  :hook (after-init . savehist-mode)
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 100)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-to-list 'savehist-additional-variables 'kill-ring))
#+end_src

** Themes

The look of Emacs is defined in a theme. Custom themes usually alter
e.g. the colors used to highlight headings or code. Readability and
accessibility has highest priority. This may be to the expense of
having a "stylish" looking Emacs, but that's OK.

I found out about the =Modus= themes created by [[https://protesilaos.com][Protesilaos Stavrou]]
while watching one of his videos about Emacs. Those themes are conform
with the highest accessibility standard for color contrast between
background and foreground values (WCAG AAA).

The themes are shipped with Emacs since version =28.1=. The latest
version is also available from ELPA. The ELPA version is the one I
use.

=Modus Operandi= is the light variant.
=Modus Vivendi= is the dark variant.

The themes come with a lot of options for customization. If those are
used, they need to be set prior to the loading of the theme.

#+begin_src emacs-lisp :tangle "init.el"
(use-package modus-themes
  :ensure t
  :demand t
  :bind (("<f5>" . modus-themes-toggle)
         ("C-<f5>" . modus-themes-select))
  :config
  (setq modus-themes-to-toggle '(modus-operandi modus-vivendi))
  (modus-themes-load-theme (cadr modus-themes-to-toggle)))
#+end_src

** Auto Revert Buffers

Ensures that external changes to a file are updated in the buffer
holding the content of that file.

#+begin_src emacs-lisp :tangle "init.el"
(use-package autorevert
  :ensure nil
  :hook (after-init . global-auto-revert-mode)
  :config
  (setq auto-revert-verbose t))
#+end_src

** Delete Selected Text Upon Insertion of New Text

The sane way of working with text is to delete a selected text on
insertion of new text. Emacs appends the inserted text to the
selection by default.

#+begin_src emacs-lisp :tangle "init.el"
(use-package delsel
  :ensure nil
  :hook (after-init . delete-selection-mode))
#+end_src

** Display Date and Time

With ~display-time-mode~ enabled, the mode line contains the current
date and time. This is the only information needed from this function.
All other options are disabled.

#+begin_src emacs-lisp :tangle "init.el"
(use-package time
  :ensure nil
  :hook (after-init . display-time-mode)
  :config
  (setq display-time-format " %a %e %b, %H:%M %Z ")
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)
  (setq display-time-mail-directory nil)
  (setq display-time-mail-function nil)
  (setq display-time-use-mail-icon nil)
  (setq display-time-mail-string nil)
  (setq display-time-mail-face nil)
  (setq display-time-string-forms
        '((propertize
           (format-time-string display-time-format now)
           'face 'display-time-date-and-time
           'help-echo (format-time-string "%a %b %e, %Y" now))
          " ")))
#+end_src

** World Clock

As I work with people in different time zones, the function =M-x
world-clock= provides a handy overview of the time across different
regions of the world.

#+begin_src emacs-lisp :tangle "init.el"
(use-package time
  :ensure nil
  :commands (world-clock)
  :config
  (setq display-time-world-list t)
  (setq zoneinfo-style-world-list ; M-x shell RET timedatectl list-timezones
        '(("America/Los_Angeles" "Los Angeles")
          ("America/Vancouver" "Vancouver")
          ("Canada/Pacific" "Canada/Pacific")
          ("America/Chicago" "Chicago")
          ("Brazil/Acre" "Rio Branco")
          ("America/New_York" "New York")
          ("Canada/Atlantic" "Canada/Atlantic")
          ("Brazil/East" "Brasília")
          ("UTC" "UTC")
          ("Europe/Lisbon" "Lisbon")
          ("Europe/Brussels" "Brussels")
          ("Europe/Athens" "Athens")
          ("Asia/Riyadh" "Riyadh")
          ("Asia/Tehran" "Tehran")
          ("Asia/Tbilisi" "Tbilisi")
          ("Asia/Yekaterinburg" "Yekaterinburg")
          ("Asia/Kolkata" "Kolkata")
          ("Asia/Singapore" "Singapore")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Seoul" "Seoul")
          ("Asia/Tokyo" "Tokyo")
          ("Asia/Vladivostok" "Vladivostok")
          ("Australia/Brisbane" "Brisbane")
          ("Australia/Sydney" "Sydney")
          ("Pacific/Auckland" "Auckland")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z (%Z)	%A %d %B")
  (setq world-clock-buffer-name "*world-clock*")
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60))
#+end_src
